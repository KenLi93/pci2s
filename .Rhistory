Xw00j <- Xw00[[j]]
offset_j <- etaW
if (is.null(offset_j)) {
offset_j <- rep(0, nn)
}
W_model[[j]] <- logit_reg(y = Wj, x = Xwj, offset = offset_j,
variance = T)
## no nuisance parameter
param_1s[[j]] <- W_model[[j]]$ESTIMATE
U1j[[j]] <- W_model[[j]]$EST_FUNC
J1j[[j]] <- W_model[[j]]$JACOBIAN
nparam1_main[j] <- length(W_model[[j]]$ESTIMATE)
W_hat[, j] <- c(Xw00j %*% param_1s[[j]])
}
## second-stage model: for each non-reference category of Y, fit the
## logistic regression model with the outcome against A, X, W, and
## predictors of W
if (variance) {
summary_second_stage <- vector("list", length = nY - 1)
}
for (k in 1:(nY - 1)) {
Yk <- Y0[, k]
logit_reg_result <- logit_reg(y = Yk, x = cbind(1, A0, Xy0[[k]], W0, W_hat), offset = eta0)
param_2s <- logit_reg_result$ESTIMATE
params <- as.numeric(c(unlist(param_1s), param_2s))
if (variance) {
np_s2 <- length(param_2s) ## number of parameters in the second stage model
par_W <- tail(params, nW - 1)  ## parameters associated with W_hat
U1 <- suppressMessages(as.matrix(dplyr::bind_cols(U1j)))
J11 <- as.matrix(Matrix::bdiag(J1j))
U2 <- logit_reg_result$EST_FUNC # make predictors of W
U <- cbind(U1, U2)
## Jacobian matrix
## make predictors of W
np_s2 <- length(param_2s)
S2 <- as.matrix(cbind(1, A0, Xy0[[k]], W0, W_hat))
J12 <- matrix(0, nrow = sum(nparam1_main), ncol = np_s2)
J21_i <- array(0, dim = c(np_s2, sum(nparam1_main), nn))
## the last nW rows of Jacobian of M against gamma for each individual
dW_i <- array(0, dim = c(nW - 1, sum(nparam1_main), nn))
for (i in 1:nn) {
S1i <- lapply(Xw00, function(x) t(x[i,]))
dW_i[, , i] <- as.matrix(Matrix::bdiag(S1i))
}
## Jacobian for every individual
for (i in 1:nn) {
dS2_i <- rbind(matrix(0, nrow = 1 + ncol(A0) + ncol(Xy0[[k]]) + ncol(W0), ncol = sum(nparam1_main)),
dW_i[, , i])
mu_i <- expit(eta0[i] + c(S2[i, ] %*% param_2s))
J21_i[, , i] <- dS2_i * (Y0[i] - mu_i) -
c(S2[i, ]) %*% t(param_2s) %*% dS2_i *
exp(eta0[i] + c(S2[i, ] %*% param_2s)) / (1 + exp(eta0[i] + c(S2[i, ] %*% param_2s))) ^ 2
}
J21 <- apply(J21_i, c(1, 2), sum)
## average derivative matrix among the at-risk at each time point
J22 <- logit_reg_result$JACOBIAN
JJ <- rbind(cbind(J11, J12), cbind(J21, J22))
Jinv <- solve(JJ)
DD <- t(U) %*% U
VAR <- Jinv %*% DD %*% t(Jinv)
all_se <- sqrt(diag(VAR))
se_2s <- tail(sqrt(diag(VAR)), np_s2)
summ_main <- matrix(NA, nrow = length(param_2s), ncol = 4)
summ_main[, 1] <- param_2s
summ_main[, 2] <- se_2s
summ_main[, 3] <- param_2s / se_2s
summ_main[, 4] <- pchisq((param_2s / se_2s) ^ 2, df = 1, lower.tail = F)
colnames(summ_main) <- c("Estimate", "Std. Error", "z value",
"Pr(>|z|)")
rownames(summ_main) <- c("(Intercept)", colnames(A0), colnames(Xy0[[k]]),
colnames(W0), colnames(W_hat))
summary_second_stage[[k]] <- summ_main
}
}
if (variance) {
summ_nuisance <- lapply(W_model, function(x) x$summary)
names(summ_nuisance) <- colnames(W0)
names(summary_second_stage) <- colnames(Y0)
return(list(ESTIMATE = param_2s,
SE = se_2s,
summary_first_stage = summ_nuisance,
summary_second_stage = summary_second_stage))
}
return(list(ESTIMATE = as.numeric(param_2s),
PARAM = as.numeric(unlist(c(param_1s, param_2s)))))
}
pci_result <- pci.logitreg(Y = Y, A = A, X = X,
W = W, Z = Z)
pci_result$summary_first_stage
pci_result$summary_second_stage
document()
library(devtools)
document()
install()
library(pci2s)
library(roxygen2)
library(devtools)
install()
library(pci2s)
?pci.logitreg
#' Linear model
#'
#' Fit linear model E[Y | X] = offset + beta * x
#' @param y n-vector of outcome
#' @param x design matrix
#' @param offset n-vector of offset
#' @param variance whether to return the variance and components for the calculation
#' @examples
#' x <- rep(1:3, each = 10)
#' y <- rnorm(30, 5 + 2 * x, 1)
#'
#' lm_result <- linear_fit(y, cbind(1, x))
#' lm_result$summary
#' @export
linear_fit <- function(y, x, offset = rep(0, length(y)),
variance = TRUE) {
if (class(x)[[1]] %in% c("matrix", "data.frame", "array")) {
x <- as.matrix(x)
} else {
x <- matrix(x, nrow = nn)
}
## estimate the regression coefficients
param <- c(solve(t(x) %*% x) %*% t(x) %*% (y - offset))
## linear predictor
PREDICT <- c(x %*% param)
if (variance) {
## Jacobian matrix of the estimating function
J <- - t(x) %*% x
U <- x * c(y - offset - x %*% param)
Umat <- t(U) %*% U
Jinv <- solve(J)
VAR <- Jinv %*% Umat %*% t(Jinv)
SE <- sqrt(diag(VAR))
summ <- matrix(NA, nrow = length(param), ncol = 4)
summ[, 1] <- param
summ[, 2] <- SE
summ[, 3] <- param / SE
summ[, 4] <- pchisq((param / SE) ^ 2, df = 1, lower.tail = F)
if (is.null(colnames(x))) {
if (ncol(x) == 1) {
rownames(summ) <- "x"
} else {
rownames(summ) <- paste0("x", 1:ncol(x))
}
} else {
rownames(summ) <- colnames(x)
}
colnames(summ) <- c("Estimate", "Std. Error", "z value",
"Pr(>|z|)")
return(list(ESTIMATE = param,
PREDICT = PREDICT,
SE = SE,
JACOBIAN = J,
EST_FUNC = U,
Umat = Umat,
summary = summ))
} else {
return(list(ESTIMATE = param, PREDICT = PREDICT))
}
}
X = NULL
Z = NULL
Xw = NULL
Xy = NULL
nco_type = NULL
nco_args = NULL
variance = TRUE
verbose = F
offset = rep(0, length(Y))
offset = rep(0, length(Y))
y = c(1, 0, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0)
a = c(0, 0, 1, 0, 1, 1, 1, 0 ,1, 0, 1, 1, 1, 1, 0)
z = c(3, 4, 5, 6, 1, 2, 4, 1, 1, 4, 3, 7, 1, 3, 3)
w = c(1, 0, 0, 0, 1, 1, 1, 0 ,0, 1 ,0, 1, 0, 1, 1)
Y = y; A = a; Z = z; W = w
offset = rep(0, length(Y))
nn <- length(Y)
# clean data type
Y0 <- as.numeric(Y)
eta0 <- as.numeric(offset)
W0 <- matrix(as.matrix(W), nrow = length(Y0))
nW <- ncol(W0)
## add column names to W if needed
if (nW == 1) {
colnames(W0) <- "W"
} else {
if (is.null(colnames(W))) {
colnames(W0) <- paste0("W", 1:nW)
} else {
colnames(W0) <- colnames(as.data.frame(W))
}
}
if (!is.null(X)) {
X0 <- as.matrix(X)
} else {
X0 <- X
}
X0
nX <- ncol(X0)
nX
nX <- ifelse(is.null(X0), 0, ncol(X0))
nX
## add column names to X if needed
if (!is.null(X0)) {
if (nX == 1) {
colnames(X0) <- "X"
} else if (nX > 0) {
if (is.null(colnames(X))) {
colnames(X0) <- paste0("X", 1:nX)
} else {
colnames(X0) <- colnames(as.data.frame(X))
}
}
}
A0 <- matrix(as.numeric(A), nrow = nn)
if (ncol(A0) == 1){
colnames(A0) <- "A"
} else {
colnames(A0) <- paste0("A", 1:ncol(A0))
}
if (is.null(nco_type)) {
nco_type <- rep("linear", nW)
}
if (length(nco_type) != nW) {
stop("length of nco_type should equal the number of columns of W.")
}
#
if (!all(nco_type %in% c("linear", "poisson", "negbin", "loglin", "ah"))) {
stop("'nco_type' should be left empty or one of 'linear', 'poisson', 'negbin',
'loglin', and 'ah'.")
}
if (is.null(Xw)) {
if (is.null(Z)) {
stop("One of Z and Xw needs to be specified")
} else {
## Default
Z0 <- as.matrix(Z)
nZ <- ncol(Z0)
## add column names to Z if needed
if (!is.null(Z0)) {
if (nZ == 1) {
colnames(Z0) <- "Z"
} else if (nZ > 0) {
if (is.null(colnames(Z))) {
colnames(Z0) <- paste0("Z", 1:nZ)
} else {
colnames(Z0) <- colnames(as.data.frame(Z))
}
}
}
paste_int <- function(a1, a2) paste(a1, a2, sep = ":")
int_names <- function(names1, names2) c(outer(names1, names2, paste_int))
int_mat <- function(a1, a2) {
dplyr::bind_cols(apply(a2, 2, function(aa) a1 * aa, simplify = F))
}
if (is.null(X0)) {
Xw0 <- lapply(1:nW, function(i) {  ## if no covariates, design matrix is A, Z and their interaction
if (nco_type[i] != "ah") {
xw <- as.matrix(cbind(1, A0, Z0, int_mat(Z0, A0)))
colnames(xw) <- c("(Intercept)", colnames(A0), colnames(Z0),
int_names(colnames(Z0), colnames(A0)))
} else {
xw <- as.matrix(cbind(A0, Z0, int_mat(Z0, A0)))
colnames(xw) <- c(colnames(A0), colnames(Z0), int_names(colnames(Z0), colnames(A0)))
}
return(xw)
})
} else {
Xw0 <- lapply(1:nW, function(i) { ## with covariates, design matrix is A, Z, X and AZ, AX interactions
if (nco_type[i] != "ah") {
xw <- as.matrix(cbind(1, A0, X0, Z0, int_mat(X0, A0), int_mat(Z0, A0)))
colnames(xw) <- c("(Intercept)", colnames(A0), colnames(X0), colnames(Z0),
int_names(colnames(X0), colnames(A0)),
int_names(colnames(Z0), colnames(A0)))
} else {
xw <- as.matrix(cbind(A0, X0, Z0, int_mat(X0, A0), int_mat(Z0, A0)))
colnames(xw) <- c(colnames(A0), colnames(X0), colnames(Z0),
int_names(colnames(X0), colnames(A0)),
int_names(colnames(Z0), colnames(A0)))
}
return(xw)
})
}
}
} else {
if (is.data.frame(Xw) | is.matrix(Xw)) {  ## same design matrix for every NCO
Xw0 <- lapply(1:nW, function(i) {
xw <- as.matrix(Xw)
colnames(xw) <- colnames(Xw)
return(xw)
})
} else {
if (is.list(Xw)) {
Xw0 <- lapply(Xw, function(xwi) {
xw <- as.matrix(xwi)
colnames(xw) <- colnames(xwi)
})
}
}
}
Xw0
if (is.null(Xy)) {
Xy0 <- X0
} else {
Xy0 <- matrix(as.matrix(Xy), nrow = nn)
if (ncol(Xy0) == 1)  {
colnames(Xy0) <- "X"
} else {
colnames(Xy0) <- paste0("X", 1:ncol(Xy0))
}
}
Xy0
if (is.null(nco_args)) {
nco_args <- lapply(1:nW,
function(i) {
if (nco_type[i] == "ah") {
list(offset = rep(0, nn),
event = rep(1, nn))
} else if (nco_type[i] == "negbin") {
list(offset = rep(0, nn),
init = NA)
} else {
list(offset = rep(0, nn))
}
})
} else {
if (!is.list(nco_args)) {
stop("nco_args should either be left empty or a list of length ncol(W)")
} else if (length(nco_args) != nW) {
stop("nco_args should be a list of length ncol(W)")
}
}
## first-stage model: for jth entry of W, fit the corresponding model
## record the parameters, estimating equations, Jacobian, and number of
## regression coefficients and nuisance parameters (for negative binomial regression)
W_model <- param_1s <- U1j <- J1j <- vector("list", length = nW)
nparam1_main <- nparam1_nuisance <- rep(NA, nW)
## predictor of W
W_hat <- matrix(nrow = nn, ncol = nW)
colnames(W_hat) <- colnames(W0)
## in the custom functions, make sure the nuisance parameters are before the regression
## coefficients
for (j in 1:nW) {
Wj <- W0[, j]
Xwj <- Xw0[[j]]
offset_j <- nco_args[[j]]$offset
if (is.null(offset_j)) {
offset_j <- rep(0, nn)
}
event_j <- nco_args[[j]]$event
if (nco_type[j] == "ah" & is.null(event_j)) {
warning("Event indicator for the NCO not specified -- assume no censoring.")
event_j <- rep(1, nn)
}
init_j <- nco_args[[j]]$init
if (is.null(init_j)) {
init_j <- NA
}
if (nco_type[j] == "linear") {
W_model[[j]] <- linear_fit(y = Wj, x = Xwj, offset = offset_j,
variance = T)
## no nuisance parameter
param_1s[[j]] <- W_model[[j]]$ESTIMATE
U1j[[j]] <- W_model[[j]]$EST_FUNC
J1j[[j]] <- W_model[[j]]$JACOBIAN
nparam1_main[j] <- length(W_model[[j]]$ESTIMATE)
nparam1_nuisance[j] <- 0
W_hat[, j] <- c(Xwj %*% param_1s[[j]])
} else if (nco_type[j] == "loglin") {
W_model[[j]] <- loglin_fit(y = Wj, x = Xwj, offset = offset_j,
variance = T)
## no nuisance parameter
param_1s[[j]] <- W_model[[j]]$ESTIMATE
U1j[[j]] <- W_model[[j]]$EST_FUNC
J1j[[j]] <- W_model[[j]]$JACOBIAN
nparam1_main[j] <- length(W_model[[j]]$ESTIMATE)
nparam1_nuisance[j] <- 0
W_hat[, j] <- c(Xwj %*% param_1s[[j]])
} else if (nco_type[j] == "poisson") {
W_model[[j]] <- poisson_fit(y = Wj, x = Xwj, offset = offset_j,
variance = T)
## no nuisance parameter
param_1s[[j]] <- W_model[[j]]$ESTIMATE
U1j[[j]] <- W_model[[j]]$EST_FUNC
J1j[[j]] <- W_model[[j]]$JACOBIAN
nparam1_main[j] <- length(W_model[[j]]$ESTIMATE)
nparam1_nuisance[j] <- 0
W_hat[, j] <- c(Xwj %*% param_1s[[j]])
} else if (nco_type[j] == "ah") {
W_model[[j]] <- lin_ah(time = Wj, event = event_j,
covariates = Xwj, offset = offset_j)
## no nuisance parameter
param_1s[[j]] <- W_model[[j]]$ESTIMATE
U1j[[j]] <- W_model[[j]]$EST_FUNC
J1j[[j]] <- W_model[[j]]$JACOBIAN
nparam1_main[j] <- length(W_model[[j]]$ESTIMATE)
nparam1_nuisance[j] <- 0
W_hat[, j] <- c(Xwj %*% param_1s[[j]])
} else if (nco_type[j] == "negbin") {
W_model[[j]] <- negbin_fit(y = Wj, x = Xwj, offset = offset_j,
variance = T, init = init_j)
## one nuisance parameter
param_1s[[j]] <- W_model[[j]]$ESTIMATE
U1j[[j]] <- W_model[[j]]$EST_FUNC
J1j[[j]] <- W_model[[j]]$JACOBIAN
nparam1_main[j] <- length(W_model[[j]]$ESTIMATE) - 1
nparam1_nuisance[j] <- 1
W_hat[, j] <- c(Xwj %*% param_1s[[j]][-1])
}
}
W_hat
## second-stage model: fit the additive hazards model with the outcome against A, X and
## predictors of W
lm_result <- linear_fit(y = Y0, x = cbind(1, A0, Xy0, W_hat), offset = eta0)
param_2s <- lm_result$ESTIMATE
params <- as.numeric(c(unlist(param_1s), param_2s))
# The number of stage 1 parameters is only correct for when stage 1 is negative binomial and additive hazard models
negbin.stage1.nparam  <-  (1 + 1 + ncol(A0) + ncol(X0) + ncol(Z0) + ncol(A0) * ncol(X0) + ncol(A0) * ncol(Z0))*sum(nco_type == 'negbin') # Each negbin has 1 nuisance + intercept + A + X + Z + AX + AZ
ah.stage1.nparam  <- (ncol(A0) + ncol(X0) + ncol(Z0) +  ncol(A0) * ncol(X0) + ncol(A0) * ncol(Z0)) * sum(nco_type == 'ah')  # Each ah has  A + X + Z + AX + AZ (no intercept)
stage2.nparam  <- (1 + ncol(A0) + ncol(Xy0) + ncol(W_hat)) # nuisance + intercept + A + X + W_hat
print(sprintf('Number of params: Negbin stage 1: %d, AH stage 1: %d, stage2: %d, total: %d, check: %d', negbin.stage1.nparam, ah.stage1.nparam, stage2.nparam, negbin.stage1.nparam+ah.stage1.nparam+stage2.nparam, length(params)))
negbin.stage1.nparam
sum(nco_type == 'negbin')
verbose
ncol(A0)
ncol(X0)
ncol(Z0)
ncol(A0) * ncol(X0) + ncol(A0) * ncol(Z0)
ncol(A0) * ncol(Z0)
if (verbose) {
# The number of stage 1 parameters is only correct for when stage 1 is negative binomial and additive hazard models
negbin.stage1.nparam  <-  (1 + 1 + ncol(A0) + ncol(X0) + ncol(Z0) + ncol(A0) * ncol(X0) + ncol(A0) * ncol(Z0))*sum(nco_type == 'negbin') # Each negbin has 1 nuisance + intercept + A + X + Z + AX + AZ
ah.stage1.nparam  <- (ncol(A0) + ncol(X0) + ncol(Z0) +  ncol(A0) * ncol(X0) + ncol(A0) * ncol(Z0)) * sum(nco_type == 'ah')  # Each ah has  A + X + Z + AX + AZ (no intercept)
stage2.nparam  <- (1 + ncol(A0) + ncol(Xy0) + ncol(W_hat)) # nuisance + intercept + A + X + W_hat
print(sprintf('Number of params: Negbin stage 1: %d, AH stage 1: %d, stage2: %d, total: %d, check: %d', negbin.stage1.nparam, ah.stage1.nparam, stage2.nparam, negbin.stage1.nparam+ah.stage1.nparam+stage2.nparam, length(params)))
}
np_s2 <- length(param_2s) ## number of parameters in the second stage model
par_W <- tail(params, nW)  ## parameters associated with W_hat
U1 <- suppressMessages(as.matrix(dplyr::bind_cols(U1j)))
J11 <- as.matrix(Matrix::bdiag(J1j))
U2 <- lm_result$EST_FUNC # make predictors of W
U <- cbind(U1, U2)
## Jacobian matrix
## make predictors of W
np_s2 <- length(param_2s)
S2 <- as.matrix(cbind(1, A0, Xy0, W_hat))
S2
J12 <- matrix(0, nrow = sum(nparam1_main) + sum(nparam1_nuisance), ncol = np_s2)
J21_i <- array(0, dim = c(np_s2, sum(nparam1_main), nn))
## the last nW rows of Jacobian of M against gamma for each individual
dW_i <- array(0, dim = c(nW, sum(nparam1_main), nn))
for (i in 1:nn) {
S1i <- lapply(Xw0, function(x) t(x[i,]))
dW_i[, , i] <- as.matrix(Matrix::bdiag(S1i))
}
## Jacobian for every individual
for (i in 1:nn) {
dS2_i <- rbind(matrix(0, nrow = 1 + ncol(A0) + ncol(Xy0), ncol = sum(nparam1_main)),
dW_i[, , i])
mu_i <- eta0[i] + c(S2[i, ] %*% param_2s)
J21_i[, , i] <- dS2_i * (Y0[i] - mu_i) - c(S2[i, ]) %*% t(param_2s) %*% dS2_i
}
1 + ncol(A0) + ncol(Xy0)
Xy0
ifelse(is.null(Xy0), 1 + ncol(A0), 1 + ncol(A0) + ncol(Xy0))
## Jacobian for every individual
for (i in 1:nn) {
dS2_i <- rbind(matrix(0, nrow = ifelse(is.null(Xy0), 1 + ncol(A0),
1 + ncol(A0) + ncol(Xy0)),
ncol = sum(nparam1_main)),
dW_i[, , i])
mu_i <- eta0[i] + c(S2[i, ] %*% param_2s)
J21_i[, , i] <- dS2_i * (Y0[i] - mu_i) - c(S2[i, ]) %*% t(param_2s) %*% dS2_i
}
J21_main <- apply(J21_i, c(1, 2), sum)
## add columns of zero for nuisance parameter
J21 <- NULL; nmain <- 0;
for (w in 1:nW) {
if (nparam1_nuisance[w] > 0) {
J21 <- cbind(J21, matrix(0, nrow = np_s2, ncol = nparam1_nuisance[w]))
}
J21 <- cbind(J21, J21_main[, (nmain + 1):(nmain + nparam1_main[w])])
nmain <- nmain + nparam1_main[w]
}
J22 <- lm_result$JACOBIAN
JJ <- rbind(cbind(J11, J12), cbind(J21, J22))
if (verbose) {
dout  <- svd(JJ)$d
print(sprintf('Condition number of the Fisher information matrix is %1.1e', dout[1]/dout[length(dout)]))
}
Jinv <- solve(JJ)
DD <- t(U) %*% U
VAR <- Jinv %*% DD %*% t(Jinv)
all_se <- sqrt(diag(VAR))
se_2s <- tail(sqrt(diag(VAR)), np_s2)
summ_main <- matrix(NA, nrow = length(param_2s), ncol = 4)
summ_main[, 1] <- param_2s
summ_main[, 2] <- se_2s
summ_main[, 3] <- param_2s / se_2s
summ_main[, 4] <- pchisq((param_2s / se_2s) ^ 2, df = 1, lower.tail = F)
summ_main
colnames(summ_main) <- c("Estimate", "Std. Error", "z value",
"Pr(>|z|)")
rownames(summ_main) <- c("(Intercept)", colnames(A0), colnames(Xy0), colnames(W_hat))
rownames(summ_main)
summ_nuisance
summ_nuisance <- lapply(W_model, function(x) x$summary)
if (nW > 1) names(summ_nuisance) <- paste0("W", 1:nW)
list(ESTIMATE = param_2s,
SE = se_2s,
summary_first_stage = summ_nuisance,
summary_second_stage = summ_main)
